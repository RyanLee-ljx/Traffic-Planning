%% 此函数是主函数
clc,clear
%% 网络参数
W = zeros(50,50);    % 初始化邻接矩阵W
W(1,[2 3 11])=[100 200 1400];
W(2,[1 4 9])=[100 400 400];
W(3,[1 6 8])=[200 300 600];
W(4,[2 5 9])=[400 800 200];
W(5,[4 11 12])=[800 100 200];
W(6,[3 7 23])=[300 300 750];
W(7,[6 20 26])=[300 150 600];
W(8,[3 10 39])=[600 200 800];
W(9,[2 4 10])=[400 200 400];
W(10,[8 9 18])=[200 400 400];
W(11,[1 5])=[1400 100];
W(12,[5 13 15])=[200 50 150];
W(13,[12 14 16])=[50 50 150];
W(14,[13 17 18])=[50 150 300];
W(15,[12 16])=[150 50];
W(16,[13 15 17])=[150 50 50];
W(17,[14 16])=[150 50];
W(18,[10 14 19])=[400 300 100];
W(19,[18 44 46])=[100 100 200];
W(20,[7 29 39])=[150 500 900];
W(21,[22 23])=[300 300];
W(22,[21 24])=[300 300];
W(23,[6 21 25 26])=[750 300 100 300];
W(24,[22 25 28])=[300 200 300];
W(25,[23 24 27])=[100 200 300];
W(26,[7 23 27 29])=[600 300 100 300];
W(27,[25 26 28 30])=[300 100 130 130];
W(28,[24 27 31])=[300 130 130];
W(29,[20 26 32 34])=[500 300 80 200];
W(30,[27 31 32])=[130 130 200];
W(31,[28 30 33])=[130 130 400];
W(32,[29 30 33])=[80 200 220];
W(33,[31 32 36 38])=[400 220 100 100];
W(34,[29 35 36])=[200 100 120];
W(35,[34 37 39])=[100 120 600];
W(36,[33 34 37])=[100 120 100];
W(37,[35 36 38])=[120 100 100];
W(38,[33 37 41])=[100 100 300];
W(39,[8 20 35 40])=[800 900 600 200];
W(40,[39 43 45])=[200 100 150];
W(41,[38 42 50])=[300 120 300];
W(42,[41 43 49])=[120 300 100];
W(43,[40 42 47])=[100 300 50];
W(44,[19 45 46])=[100 300 100];
W(45,[40 44 47])=[150 300 100];
W(46,[19 44])=[200 100];
W(47,[43 45 48])=[50 100 100];
W(48,[47 49 50])=[100 300 200];
W(49,[42 48])=[100 300];
W(50,[41 48])=[300 200];
% tf = issymmetric (W) ;  % 判断矩阵是否为对称矩阵，从而判断输入是否有误
W(W==0)= 100000;   %将邻接矩阵中0的元素替换为一个特别大的数10000，表示不连接距离均视为无穷大
W(diag(true(size(W,1),1))) = 0;    % 把对角线元素选出来替换为0，自己与自己的距离当然为0
o1 = 22;   % 指定起点1
d1 = 44;   % 指定终点1
o2 = 1;   % 指定起点2
d2 = 50;   % 指定终点2
%% 绘制网络图
Wij = W;
Wij(Wij==100000) = 0;   % 将100000替换为0，不然会影响画图
figure(1);
G = graph(Wij);
p = plot(G, 'EdgeLabel', G.Edges.Weight, 'linewidth', 2,'NodeFontSize',12,'MarkerSize',5);
%% 0-1整数规划模型求最短路径
[P,dis,t1] = shortpath_guihua(W,o2,d2);   % 自行更改起点终点

%% 迪杰斯特拉算法
t2 = shortpath_Dijkstra(W,o2,d2);

%% 弗洛伊德算法
t3 = shortpath_Floyd(W,o2,d2);

%% 运行时间比较
figure(5);
X = categorical({'0-1规划模型','Dijkstra算法','Floyd算法'});
X = reordercats(X,{'0-1规划模型','Dijkstra算法','Floyd算法'});
Y = [t1 t2 t3];
b = bar(X,Y,0.5);
xtips1 = b.XEndPoints;
ytips1 = b.YEndPoints;
labels1 = string(b(1).YData);
text(xtips1,ytips1,labels1,'HorizontalAlignment','center',...
    'VerticalAlignment','bottom');
set(gca,'Ylim',[0,0.7]);
title('三种算法运行时间比较(单位/秒)');










